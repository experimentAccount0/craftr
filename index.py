# Copyright (c) 2017  Niklas Rosenstein
# All rights reserved.

from collections import Mapping, Sequence
from operator import itemgetter
import textwrap
import sys
argschema = require('ppym/lib/argschema')
logger = require('./logger')
path = require('./path')
platform = require('./platform')
pyutils = require('./pyutils')
shell = require('./shell')

#: This variable is bound from the command-line, specifying the action invoked
#: by the user for the build script. This can be 'run' or 'export'.
action = 'run'

#: The directory that contains data files that are generated during the build
#: but valid independent on the build configuration (for example, externally
#: downloaded files).
datadir = '.CraftrCache'

#: The build output directory. All output files should be generated inside
#: this directory. Ideally the generated files should also be namespaced
#: meaningfully. The #buildlocal() function is a helper function that will
#: turn the name of a rule into a directory name inside the build directory.
builddir = 'build'

#: The build type. This should have influence on rule generation. For example
#: a debug build should enable debug flags in compilers, unless they have
#: been explicitly turned off.
#: Valid values are 'develop', 'debug' and 'release'. The 'develop' mode is
#: the default and must not have any specific influence on generated rules.
buildtype = 'develop'

#: The backend implementation. This member is bound before the build script
#: is executed by the command-line interface.
backend = None

#: A dictionary of options that are used by various Craftr components,
#: backends and build-scripts when using the #option() function. Keys are
#: usually lowercase and namespaced as `scope:key`. Every export directory
#: will have a `.CraftrBuildCache` file that will contain the options used
#: to export the build information as well as other information such as the
#: #backend and #buildtype.
options = {}

#: The cache is stored in the project's root directory (the directory from
#: which `craftr export` is run). It contains project wide information that
#: might be generated from export to export but needs to stay consistent.
#: For example, the download location of external files is stored here since
#: this cached information is valid throughout multiple sessions.
#: The project cache is stored in a `.CraftrProjectCache` file.
cache = {}

#: A dictionary of registered #Product objects that contain information about
#: targets that can be taken into account by rules that take targets as inputs.
#: Products are associated with a target only by their name. They may exists
#: independent of targets, but a product will always be created for a target
#: if none is explicitly specified.
products = {}

#: This is the global container for build rules and targets.
build_container = require('./build').BuildContainer()

def pool(name):
  return build_container.pool(name)

def rule(name, commands, pool=None, *args, **kwargs):
  if isinstance(pool, str):
    if pool not in build_container.pools:
      raise ValueError('pool {!r} does not exist'.format(pool))
    pool = build_container.pools[pool]
  return build_container.rule(name, commands, pool, *args, **kwargs)

def target(name, rule, *args, **kwargs):
  if isinstance(rule, str):
    if rule not in build_container.rules:
      raise ValueError('rule {!r} does not exist'.format(rule))
    rule = build_container.rules[rule]
  product_ = kwargs.get('product')
  if not product:
    product_ = product(name, None)
  return build_container.target(name, rule, *args, **kwargs)

def product(name, type, meta=None, **data):
  """
  Creates a named #Product instance and returns it. A product represents
  a collection of information on a build artefact that can be included in
  other build procedures, usually libraries.

  If the #product() function is used to specify the product of an existing
  target, it can be replaced given that the #Product was automatically
  generated by the #target() function and has type #None.
  """

  if name in products:
    product = products[name]
    if product.type is not None:
      raise ValueError('product {!r} already exists'.format(name))
  product = Product(name, type, meta, data)
  products[name] = product
  return product

def option(name, type=str, default=NotImplemented, inherit=True):
  """
  Retrieve an option value of the specified *type* by *name*. If *inherit* is
  #True, the namespace of *name* will be removed and checked again. The
  namespace separate is `:`. The option value is read from the global #options
  dictionary.

  # Example

  ```python
  version = craftr.option('curl:version')
  build_examples = craftr.option('curl:build_examples', bool)
  ```
  """

  value = NotImplemented
  if name in options:
    value = options[name]
  elif ':' in name:
    name = name.split(':', 1)[1]
    if name in options:
      value = options[name]
  if value is NotImplemented:
    if default is NotImplemented:
      return type()
    return default

  if type == bool:
    value = str(value).strip().lower()
    if value in ('yes', 'on', 'true', '1'):
      value = True
    elif value in ('no', 'off', 'false', '0'):
      value = False
    else:
      raise ValueError("invalid value for option {!r} of type 'bool': {!r}"
          .format(name, value))
  else:
    try:
      value = type(value)
    except (ValueError, TypeError) as exc:
      raise ValueError("invalid value for option {!r} of type 'str': {!r} ({})"
          .format(name, value, exc))

  return value

def isref(name):
  """
  Returns #True if *name* is a reference string. Every string that begins
  with two slashes like `//...` is a reference string.
  """

  return name.startswith('//')

def resolve(name):
  """
  Resolves the refernce string *name* and returns a #Product.
  """

  if not name.startswith('//'):
    raise RuntimeError('not a reference string: "{}"'.format(name))
  name = name[2:]
  if name.startswith(':'):
    name = get_current_namespace() + name
  try:
    return products[name]
  except KeyError as exc:
    raise ResolveError("product '{}' does not exist".format(name))

def pkg_config(pkg_name, static=False):
  """
  If available, this function uses `pkg-config` to extract flags for compiling
  and linking with the package specified with *pkg_name*. If `pkg-config` is
  not available or the it can not find the package, a #PkgConfigError is raised.

  Returns a #Product object.
  """

  product_name = 'pkg-config:{}'.format(pkg_name)
  if product_name in products:
    return products[product_name]

  cmdversion = ['pkg-config', '--modversion', pkg_name]
  cmdflags = ['pkg-config', '--cflags', '--libs']
  if static:
    cmdflags.append('--static')
  cmdflags.append(pkg_name)

  try:
    flags = shell.pipe(cmdflags, check=True).stdout
    version = shell.pipe(cmdversion, check=True).stdout.rstrip()
  except FileNotFoundError as exc:
    raise PkgConfigError('pkg-config is not available ({})'.format(exc))
  except shell.CalledProcessError as exc:
    raise PkgConfigError('{} not installed on this system\n\n{}'.format(
        pkg_name, exc.stderr or exc.stdout))

  product = Product('pkg-config:' + pkg_name, 'cxx',
      meta={'name': pkg_name, 'version': version})
  # TODO: What about a C++ library? Is it okay to use ccflags nevertheless? Or
  #       how do we otherwise find out if the library is a C++ library?

  for flag in shell.split(flags):
    if flag.startswith('-I'):
      product.data.setdefault('includes', []).append(flag[2:])
    elif flag.startswith('-D'):
      product.data.setdefault('defines', []).append(flag[2:])
    elif flag.startswith('-l'):
      product.data.setdefault('libs', []).append(flag[2:])
    elif flag.startswith('-L'):
      product.data.setdefault('libpath', []).append(flag[2:])
    elif flag.startswith('-Wl,'):
      product.data.setdefault('ldflags', []).append(flag[4:])
    else:
      product.data.setdefault('ccflags', []).append(flag)

  products[product_name] = product
  return product

def grn(name, prefix):
  """
  This function can be used in functions that generate build targets if no
  rule name has been specified to retrieve a unique rule name, assuming that
  no call to #rule() follows before the rule with the returned name has been
  created.

  If *name* is specified, it will be returned as-is, unless it does not
  contain a `:` character, in in which case it is concatenated with the
  currently executed module's `namespace` variable.
  """

  if name:
    if ':' not in name:
      name = get_current_namespace() + ':' + name
    return name

  index = 0
  while True:
    name = '{}_{:0>4d}'.format(prefix, index)
    if name not in rules:
      break
    index += 1
  return name

def get_current_namespace():
  """
  Returns the value of the `namespace` variable that is specified in the
  currently executed module, or raises a #RuntimeError if it is not
  specified.
  """

  if 'namespace' not in vars(require.current.namespace):
    raise RuntimeError("Relative target name specified, but currently "
        "executed module '{}' does not provide a 'namespace' variable.\n"
        "Please put 'namespace = \"mynamespace\"' at the beginning of "
        "your Craftr build script.".format(require.current.filename))
  return require.current.namespace.namespace

def export():
  return backend.export(module.namespace)

def build(builddir, targets=()):
  return backend.build(builddir, targets)

def clean(builddir, targets=()):
  return backend.clean(builddir, targets)

def error(*objects, code=1):

  """
  Raise an #Error exception with the message specified with *objects*. If
  uncatched, the exception will be handled by a special exception handler.
  """

  raise Error(' '.join(map(str, objects)), code)


class Product(Mapping):
  """
  A #Product is an extended representation of a build target with additional
  information that is used by target generating functions. It may also
  represent externally produced build information. An example of this is the
  #pkg_config() function which returns a #Product that does not represent a
  #Target but instead an external library.

  Keys in a #Product are automatically prefixed with the product's #type as
  in `type:key`. This ensures proper namespacing of option values in products
  of different types.

  # Members
  name (str): The name of the product. For automatically generated Products
      from a target generator function, this is usually the target name.
  type (str): A product type identifier. For example, the type identifier
      for C/C++ libraries is `'cxx'`.
  data (dict): A dictionary that contains the product information. The format
      of this information depends on the Product's #types.
  """

  def __init__(self, name, type, meta, data):
    argschema.validate('name', name, {'type': str})
    argschema.validate('type', type, {'type': str})
    argschema.validate('meta', meta, {'type': [None, dict]})
    argschema.validate('data.keys()', data.keys(), {'items': {'type': str}})
    self.name = name
    self.type = type
    self.meta = meta if meta is not None else {}
    self.data = data

  def __iter__(self):
    for key in self.data:
      yield self.type + ':' + key

  def __len__(self):
    return len(self.data)

  def __contains__(self, key):
    if not key.startswith(self.type + ':'):
      return False
    key = key[len(self.type) + 1:]
    return key in self.data

  def __eq__(self, other):
    """
    Returns #True if the #other Product has at least one type in common with
    this Product and the #data matches exactly. Does **not** take the Product
    #name into account.
    """

    if not isinstance(other, Product):
      return False
    if self.type != other.type:
      return False
    return self.data == other.data

  def __repr__(self):
    return 'Product({!r}, {!r})'.format(self.name, self.type)

  def __str__(self):
    lines = ['Product({!r}, {!r})'.format(self.name, self.type)]
    if self.data or self.meta: lines[0] += ':'
    for key, value in sorted(self.data.items(), key=itemgetter(0)):
      lines.append('  | {}: {!r}'.format(key, value))
    if self.meta:
      lines.append('  Metadata:')
    for key, value in sorted(self.meta.items(), key=itemgetter(0)):
      lines.append('    | {}: {!r}'.format(key, value))
    return '\n'.join(lines)

  def __getitem__(self, key):
    argschema.validate('key', key, {'type': str})
    if not key.startswith(self.type + ':'):
      raise KeyError(key)
    try:
      return self.data[key[len(self.type) + 1:]]
    except KeyError as exc:
      raise KeyError(key) from exc

  def __setitem__(self, key, value):
    argschema.validate('key', key, {'type': str})
    if ':' in key and not key.startswith(self.type + ':'):
      raise KeyError(key)
    if ':' in key:
      key = key[len(self.type) + 1]
    self.data[key] = value

  @property
  def target(self):
    return build_container.targets.get(self.name)

class Merge(Mapping):
  """
  This class is a collection of #Mapping#s, usually #Product instances or
  #dict#ionaries, and treats them as one merged #Mapping. Additionally, it
  allows to retrieve values cummulatively using #getlist().

  Setting items on the #Merge instance will cause the value to be found
  as the first value when using #__getitem__() but will cause the value to
  be treated cumulative to previously set values when using #getlist().

  # Members
  mappings (list of Mapping): The mappings specified upon initialization.
      If one or more *recursive_keys* was specified, #Merge.expand() was
      used to expand any nested mappings into a flat list.
  used_keys (set of str): A set of the keys that have been used to access
      properties in this #Merge instance. This is used to check for unused
      option values passed to target generator functions.
  """

  def __init__(self, mappings, recursive_keys=()):
    self.mappings = list(Merge.expand(mappings, recursive_keys))
    self.mappings.insert(0, {})
    self.used_keys = set()

  @staticmethod
  def expand(mappings, recursive_keys):
    if not recursive_keys:
      yield from mappings
      return
    for obj in mappings:
      yield obj
      for key in recursive_keys:
        try:
          children = obj[key]
        except KeyError:
          pass
        else:
          if isinstance(children, Mapping):
            children = [children]
          yield from Merge.expand(children, recursive_keys)

  def __iter__(self):
    keys = set()
    for obj in self.mappings:
      for key in obj:
        if key not in keys:
          keys.add(key)
          yield key

  def __len__(self):
    return sum(1 for __ in self)

  def __contains__(self, key):
    for obj in self.mappings:
      if key in obj:
        return True
    return False

  def __str__(self):
    lines = ['Merge of:']
    for obj in self.mappings:
      lines.extend(textwrap.indent(str(obj), '  ').split('\n'))
    return '\n'.join(lines)

  def __getitem__(self, key):
    self.used_keys.add(key)
    for obj in self.mappings:
      if isinstance(obj, Mapping):
        try:
          return obj[key]
        except KeyError: pass
      else:
        try:
          return getattr(obj, key)
        except AttributeError: pass
    raise KeyError(key)

  def __setitem__(self, key, value):
    if key in self.mappings[0]:
      self.mappings.insert(0, {})
    self.mappings[key] = value

  def get(self, key, default=None):
    try:
      return self[key]
    except KeyError:
      return default

  def getlist(self, key):
    """
    Collects all values associated with the specified *key* in the objects
    passed in the #Merge constructor into a list and returns it.
    """

    self.used_keys.add(key)
    result = []
    for obj in self.mappings:
      try:
        value = obj[key]
      except KeyError:
        continue
      if isinstance(value, str) or not isinstance(value, Sequence):
        raise TypeError('expected non-string sequence for {!r}'.format(key), obj)
      result.extend(value)
    return result

class Inputs(object):
  """
  This class represents a collection of input files and target/product
  references. The constructor accepts a list of strings or #Product#s.
  References will be immediately expanded using #resolve_target() and
  #resolve_product().
  """

  def __init__(self, inputs, recursive_keys=()):
    self.files = []
    self.products = []

    argschema.validate('inputs', inputs,
        {'type': [Sequence, str, Product], 'items': {'type': [str, Product]}})
    if isinstance(inputs, (str, Product)):
      inputs = [inputs]

    for item in inputs:
      if isinstance(item, str):
        if isref(item):
          product = resolve(item)
          if product: self.products.append(product)
        else:
          self.files.append(item)
      elif isinstance(item, Product):
        products.append(item)
      else:
        assert False

      self.merge = Merge(self.products, recursive_keys=recursive_keys)

  def __iter__(self):
    return iter(self.getallfiles())

  def getoutputs(self):
    """
    Returns all output files from target referenced by the input files.
    These are the files that are returned by #getallfiles() but are not
    contained in #files.
    """

    files = []
    for product in self.products:
      if product.target:
        files += product.target.outputs
    return files

  def getallfiles(self):
    """
    Returns a list of all input files. This is the #files list plus all
    files output by the #targets.
    """

    return self.files + self.getoutputs()

class Error(Exception):
  """
  Raised by #error().
  """

  def __init__(self, message, code=1):
    self.message = str(message)
    self.code = code

  def __str__(self):
    return self.message

class PkgConfigError(Error):
  """
  Raised by #pkg_config().
  """

class ResolveError(Exception):
  """
  Raised when a target or product name could not be resolved.
  """

def local(*parts):
  """
  Accepts a relative path and returns its absolute representation, assuming
  it be relative to the currently executed module.
  """

  return path.norm(path.join(*parts), require.current.directory)

def buildlocal(*parts):
  """
  Accepts a relative path and returns its absolute representation, assuming
  it be relative to the build output directory specified in #builddir.

  If a `:` appears in the path passed to this function, it will be replaced
  by #path.sep. This is to conveniently support generating a build output
  directory from a target name,
  """

  p = path.join(*parts).replace(':', path.sep)
  return path.norm(p, path.abs(builddir))

def register_nodepy_extension():
  """
  Registers `Craftrfile` to the current Node.py Context's index files and
  associates it to be loaded with the `.py` loader.
  """

  require.context.register_index_file('Craftrfile')
  require.context.register_extension('Craftrfile', require.context.get_extension('.py'))
